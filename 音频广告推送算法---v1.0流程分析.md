#音频广告推送算法---v1.0流程分析
## 写在前面
--------------------------------
这是对第一个版本v1.0流程的一些个人想法。也包括了一些技术点。
我认为先开发出一个简单可用的版本并在后续不断优化，要好于上来就设计一个大而复杂的模型，并且拥有更好的灵活性。

## 输入
--------------------------------
输入是由广告主决定的：  
    1 音频广告的标签，可能会有多个。
    2 每次推送的次数(我们也可以根据具体的标签给他一个次数的建议)<br>

## 我们需要做的事情：
--------------------------------
一、获取所有用户的行为。<br>
>   1 包括baiduID，userID(针对登陆用户)听歌时间，听歌时长，听歌内容(歌曲、歌手),设备型号，地理区域等。<br>
    2 最好有一个独立的ETL来获取这些数据。<br>
    3 Q:这个数据量会非常的大，怎样保存中间结果？<br>
    4 Q:怎样获取用户的行为？不是所有人，每天都使用产品的。若是以他最近一次的行为，那么获取全量用户时存在些麻烦。<br>

二、提取其中的登陆用户的属性。<br>
>   1 Q:这个数据量会非常的大，怎样保存中间结果？<br>

三、根据用户的行为和已有的登陆用户的属性，为非登录用户添加属性。<br>
>   1 Q:怎样才算是相似的？<br>
    2 Q:采用K-近邻算法将会极其耗费时间。因为每为一个非登录用户添加属性，都会遍历一遍所有登陆用户的属性。<br>
    3 Q:匹配时的行为维度不会是一样的权值。那么如何确定其权值？<br>
    4 这样的话，在匹配时，最好将用户的一些连续行为做离散化处理。<br>
    5 A:可以不使用KNN，而是设定一个阀值，这样在匹配非登录用户时，找到的第一个高于阀值的登陆用户，我们就认为他们有相同的属性。<br>
    6 Q:像上面所言，如何避免每次都从开头匹配，这样很容易和排在前面的登录用户匹配上的问题？<br>
         A:可以每次在登陆用户中，随机选择一个开始向下匹配。<br>
    7 Q:还是数据量大，保存的问题。<br>

四、筛选出符合条件的用户，为其推荐音频广告。<br>
>   1 根据广告主提出的标签来进行匹配，查找包含该标签的用户。<br>
    2 若是查找到的用户数量大于每次需要推送次数，则需要进行排序。越多标签符合的用户应该越靠前。<br>
    3 若是查找到的用户数量小于每次需要推送次数时：
      3.1 小于但是相差不大时：我们可以就推送这些用户，与广告主进行协商或是增加、多推荐的频度。<br>
      3.2 若是明显小于推送次数时：我们应该在登陆用户进行两两相似匹配，若是两个登陆的属性很相似，那么我们取他们属性的并集，将这个并集赋给这两个用户。<strong>(这个工作量会比较大)</strong><br>
    当然，希望推送的次数恰好等于我们筛选出来的用户数量，这样的概率是极小的。<br>
    4 Q:若A有100个属性，B有20个属性，那么进行标签匹配时，推送给A的概率就明显大于B了。这是不公平的。如何避免这种不公平(毕竟谁都不想被广告骚扰)？<br>
    5 Q:假定选出了10w待推送广告的用户，但是你不能保证这10w在短期内都会有使用，那么这样的话，就存在有些人的广告不能推送出去。此时该如何处理？<br>

## 后续可优化点：
-------------------------------
>   1 在用户收听的内容上深入做文章。毕竟喜欢同一个歌手的用户，他们的年龄兴趣相似可能性也大。<br>
    2 优化各个行为的权值。<br>
    3 对登陆用户的属性值加以利用。<br>  

######(以上问题写于2014-10-08，后续再更新)-----------
<br>
## 更新：
--------------------------------
1 上面设计的是基于用户上一次的行为设计的流程。但这样做会有一些麻烦：
>   1.1 新用户首次使用时是不会进行推送的。而新用户的比重很大。<br>
    1.2 事先选好的用户，不能保证短期内都会推送出去。<br>
    1.3 存储量非常的大，BaiduID在音乐端多达55亿+。（截止2014-10-08）<br>
我们要放弃这种策略，采用实时行为触发的模型。

2 目前要设计成实时投放的模型，即用户触发了某种行为就会推送一个广告。<br>
  但这样做对及时性的要求就有所提高，可以以降低准确性为代价。

3 后期需要根据经验估计广告容量。<br>
  例如：10w用户使用时，或许会投放15w广告。因为有的人收听时间可能会比较长，可能每听5首歌推荐一个音频。这样的话，这一个用户可能就是投放不只一个广告。

4 非登陆用户去和登陆用户匹配时，各种维度的权值根据不同的维度也应该是不同的。<br>
  即有可能母婴类的用户对内容维度相似度较大，而体育类的用户在时间上更加的相似。<br>
  因此，不同的标签要设计不同的权值list。

5 对于登陆用户，我们可以直接通过他的属性来进行推荐。这是最准确而且快捷的，也是我们期待的。<br>
  而对于非登陆的用户，我们就需要通过他的行为来预测他的属性值。<br>
  我们对非登陆用户的最终的目标是想找到`他的属性标签`，而不是`跟他最相似的K个登陆用户`。<br>
  所以，我们绕了一个圈子。<br>
  我们可以直接通过登陆用户的数据来训练一个模型，这个模型可以根据行为来直接为其预测标签。<br>
  这样就当模型训练完成后，再来对一个非登陆用户来预测就非常快了。不必再去一一比对登陆用户。

6 所以目前的主要难点和耗时点就是在于：
>   6.1 登陆用户数据的预处理。（格式，缺省值，连续值离散化等）<br>
    6.2 针对各个标签的权重计算。（还要考虑后续有新添加标签时的情况）<br>
    6.3 阈值、广告容量比值等参数值的经验估计。<br>
    6.4 满足要求用户数量低时的扩张处理。<br>

######(以上问题写于2014-10-09，后续再更新)-----------
<br>
## 更新：
--------------------------------
和web-rd以及pm沟通后，流程有所更改：<br>
1 web端给我这边传递id。我们之间有共同的标签库。然后我针对这个id，给出他对每个标签的二分判断。<br>
2 id包括userid，baiduid，cuid。若是登陆用户，不论是哪个端的都以userid为准。否则，web端看baiduid，移动端看cuid。<br>
3 确定一级标签库后，返回一个bit串给web端同学。<br>
初稿如下：<br>
![设计初稿](/images/design_ads.png)
######(以上问题写于2014-10-23，后续再更新)-----------

<br>
## 更新：
--------------------------------
在和web-rd和pm的设计串讲会后之后，数据源有重大更改。原计划由web端rd传递过来的信息（地址，歌曲id，手机类型，歌手id等等）；而是直接保留之前的传递id信息，然后以id去推荐组拿到用户的音乐画像，然后用这个音乐画像去做行业兴趣匹配。<br>
推荐组的音乐画像属性：<br>
```
age：新歌、偏新歌、不新不旧歌、偏老歌、老歌 
area： 日韩、欧美、内地、港台 
composer： 歌曲的作曲者 
emotion： 激动、轻松、不满、快乐、平静、伤感、寂寞、压抑、失望、害怕、感动、烦恼 
gender： 未知性别、男歌手、女歌手、组合歌手 
hot： 大冷门、冷门、小众、不冷不热、大众、热门、大热门 
language： 国语、韩语、日语、粤语、英语、其他语言 
lyricist： 歌曲的作词者 
rhythm： 快、中、慢、偏慢、偏快 
scene： 散步、失恋、工作、舒缓、一个人、睡眠、傍晚、运动、聚会、亲热、清晨、阅读、户外、驾驶 
singer： 歌曲的演唱者ID 
style：民谣、摇滚、布鲁斯、古典、轻音乐、雷鬼、乡村、乐器、拉丁、世界音乐、R&B、新世纪、金属、实验、流行、电子、说唱
```
可以看到其中的composer，lyricist，singer这三个类的枚举数量很大，在判别时没有什么意义。所以采用除这三者之外的其他属性。<br>
举个用户音乐属性的样例：<br>
```
618985650       
language_国语:0.8900    style_流行:0.8582    rhythm_中:0.3470   area_港台:0.2777   
gender_男歌手:0.2460  emotion_伤感:0.1401    gender_女歌手:0.1400   area_内地:0.1080 
rhythm_偏快:0.1013    language_粤语:0.0944  emotion_感动:0.0802    hot_大众:0.0799 
hot_大冷门:0.0555     rhythm_偏慢:0.0490    hot_小众:0.0418  emotion_轻松:0.0369  
age_老歌:0.0345      scene_傍晚:0.0338     scene_聚会:0.0300    emotion_平静:0.0278     
scene_户外:0.0275    style_摇滚:0.0269   hot_不冷不热:0.0262  scene_驾驶:0.0256       
scene_散步:0.0253    scene_工作:0.0245    scene_一个人:0.0243  scene_清晨:0.0242        
style_民谣:0.0241    age_偏老歌:0.0238
```
通过http接口可以进行请求：<br>
```
http://10.26.5.198/getprofile.php?id=00001990eda04ec86ddb0e239491021b8787309a
```
请求结果如下：<br>
```
{"status":0,"profile":"6_0:1.0000\t11_15:0.7434\t0_0:0.5176\t8_1:0.3550\t4_1:0.3024\t
1_2:0.2495\t3_5:0.2369\t0_4:0.1986\t4_2:0.1759\t8_4:0.1643\t5_2:0.1027\t5_4:0.0919\t
3_10:0.0834\t5_1:0.0681\t3_1:0.0509\t10_102512:0.0458\t3_6:0.0362\t3_0:0.0356\t
10_8396:0.0339\t10_61988:0.0339\t9_6:0.0314\t4_3:0.0293\t9_8:0.0287\t9_13:0.0266\t
9_12:0.0262\t0_2:0.0244\t9_10:0.0242\t9_4:0.0239\t5_0:0.0236\t9_1:0.0233"}
```
可见结果跟我们上面展示的并不相同。需要有个map进行映射才行。<br>
```
age   0  偏新歌 0 新歌  1 老歌  2 偏老歌 3 不新不旧歌  4
area  1  日韩  0 欧美  1 内地  2 港台  3
emotion 3   激动  0 轻松  1 不满  2 快乐  3平静 4 伤感  5 寂寞  6 压抑  7 失望  8 害怕  9 感动  10  烦恼  11
gender  4  未知性别  0 男歌手 1 女歌手 2 组合歌手  3
hot 5  大众  0 大冷门 1 小众  2 大热门 3不冷不热 4 冷门  5 热门  6
language 6   国语  0 韩语  1 日语  2 粤语  3 英语  4 其他语言  5
rhythm  8  快 0 中 1 慢 2 偏快  3偏慢 4
scene 9   散步  0 失恋  1 工作  2 舒缓  3浪漫 4 聚会  5 睡眠  6 傍晚  7 运动  8 一个人 9 亲热  10  户外  11  阅读  12  清晨  13  驾驶  14
style 11    民谣  0 摇滚  1 布鲁斯 2 古典  3轻音乐  4 乐器  5 乡村  6 雷鬼  7 拉丁  8 世界音乐  9 R&B 10  爵士  11  新世纪 12  金属  13  实验  14  流行  15  电子  16  说唱  17
```
这样我们就通过上面的音乐标签来训练判断非登录用户。<br>
由于上面出现了9类共计72种。每个类中的标签是可以同时存在的。若是以每个标签及其权值作为维度，那么就会有72个维度。这样可能会出现维灾难。<br>
因此，仅仅记录每个类中的权值最高标签id。<br>
这里再额外说说各种id。<br>
```
baiduid:针对pc端的标识，是针对cookie的，用户若是不清理cookie(或是cookie没有过期)
，那么同一台电脑每次登陆是同一个baiduid。
userid:针对登陆与否而判断的，不论在那个端上都是可以统一的。
但是在客户端，我们会加密成BDUSS。
cuid:针对移动端的，一台物理设备的唯一标识。
cuid和baiduid不会同时出现。
```
<br>
######(以上问题写于2014-10-30，后续再更新)-----------

因为通过执行Python脚本调用http接口获取厄里斯数据，大约需要800ms；<br>
通过http接口调用推荐组的音乐画像数据，大约需要150ms--250ms；<br>
这个性能是不能满足时间并发需求的。因此需要添加缓存机制。<br>

后续的工作计划list：<br>
1 baiduid的处理：<br>
* 确定各个阈值，标签以及概率。并修改相关联的生成随机串函数。

2 userid的处理：<br>
* 优化调用Python的函数，通过java直接调用http接口。（能不能使用离线方式，使用现成的工具）
* 若是还是使用之前的方式，那么需要解析返回json结果。
* 对json结果的处理。

3 cuid的处理：<br>
* 获取新的训练集并进行处理。
* 训练出20+的针对单标签的模型。
* 调用使用模型，拉通整体的的判断流程。
* 每次判断都要加载，优化问题。

######(以上问题写于2014-11-07，后续再更新)-----------

--------------------------------
######（转载本站文章请注明作者和出处 https://github.com/MangoLiu ，请勿用于任何商业用途）
