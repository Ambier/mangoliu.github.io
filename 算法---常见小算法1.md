#算法---常见小算法1--10
目录：<br>
1 冒泡排序<br>
2 先序遍历二叉树<br>
3 排序数组中和为给定值的两个数字<br>
4 数组中出现次数超过一半的数字<br>
5 正整数二进制表示中的1的个数<br>
6 单例模式<br>
7 判断是否所有小字符串里的字母在大字符串里都有<br>
8 找到数组中只出现一次的数字<br>
9 折半查找(二分查找)<br>
10 从第一字符串中删除第二个字符串中所有的字符<br>

----------------------------
##冒泡排序
冒泡排序算法:轻者上浮，重者下沉。（或者正好相反） <br>
**基本思想：**<br>
1.比较相邻的元素。<br>
2.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。<br>
3.针对所有的元素重复以上的步骤，除了最后一个。<br>
4.持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。<br>
本质上是：第一趟，选出最大（或最小）元素，第二趟，选出次大（或次小的）的元素…..<br>
<br>
**示例：**<br>
定义数组：{ 4, 2, 62, 9, 22, 1,14,10 }<br>
第1趟排序后：[2, 4, 9, 22, 1, 14, 10, 62]  //选取最大元素62，放在了最后<br>
第2趟排序后：[2, 4, 9, 1, 14, 10, 22, 62]  //选出了次大元素22 ，放在了倒数第二位….<br>
第3趟排序后：[2, 4, 1, 9, 10, 14, 22, 62]<br>
第4趟排序后：[2, 1, 4, 9, 10, 14, 22, 62]<br>
第5趟排序后：[1, 2, 4, 9, 10, 14, 22, 62]<br>
第6趟排序后：[1, 2, 4, 9, 10, 14, 22, 62]<br>
第7趟排序后：[1, 2, 4, 9, 10, 14, 22, 62]<br>
<br>
**代码：**<br>
```java
//沉底操作
int i,j,t;
int [] a={4,2,6,9,22,1,100};
for(i=0;i<n-1;i++){
   for(j=0;j<n-i-1;j++){   //注意这两个for循环是怎么写的。
      if(a[j]>a[j+1]){   //满足条件的话，交换两个元素。
        t=a[j];
        a[j]=a[j+1];
        a[j+1]=t;
      }
  }
}
```
**时间复杂度**：<br>
最好情况，O(n)；最坏(逆序) O(n*n)。是稳定的排序。
稳定排序：待排序的记录序列中可能存在两个或两个以上关键字相等的记录。
排序前的序列中Ri领先于Rj。若在排序后的序列中Ri仍然领先于Rj，则称所用的方法是稳定的。<br>

------
##先序遍历二叉树
**前序遍历：**先遍历父节点，然后左子节点，然后右子节点。<br>
下图的遍历顺序为：1245367<br>
![tree](/images/suanfa/20141203.png)<br>

**递归方式基本思想：**<br>
对一个树的访问，可以分成访问当前节点，访问左子树和访问右子树。而访问左右子树时又可以看做是上述步骤的重复，因此可以递归的调用。<br>

**代码：**<br>
```java
//递归方式
void preOrder(TNode* root){
    if (root != NULL){
        Visit(root);           //访问当前节点
        preOrder(root->left);   //递归访问左子节点
        preOrder(root->right);   //递归访问右子节点
    }
}
```
**非递归方式基本思想：**<br>
在访问途中将依次遇到的节点保存下来。由于节点出现次序与恢复次序是反序的，因此是一个先进后出结构，需要用栈。<br>
**代码：**<br>
```java
//非递归方式
void preOrder1(TNode* root){
    Stack S;
    while ((root != NULL) ||!S.empty()) {
        if (root != NULL) {
            Visit(root);
            S.push(root);       // 先访问，再入栈
            root = root->left;    // 依次访问左子树
        }
        else{
            root = S.pop();     // 回溯至父亲节点
            root = root->right;
        }
    }
}
```
------
##排序数组中和为给定值的两个数字
**题目：**有一个升序的数组a和一个数字N，在数组中查找两个数，使得它们的和正好是输入的那个数字。要求时间复杂度是O(n)。如果有多对数字的和等于输入的数字，输出任意一对即可。<br>

**示例：**数组1、2、4、7、11、15以及目标和15。由于4+11=15，因此输出4和11。<br>

**方案一：**穷举遍历法，一个个比对查找，但这种方法没有好好利用有序这个条件。时间复杂度为O(n*n)。<br> 
**方案二：**基本思路：找到两个数，将其和与N进行对比，并不断调整。<br>

**实现方法：**找到数组的第一个数字和最后一个数字。当两个数字的和大于输入的数字时，把较大的数字往前移动；当两个数字的和小于数字时，把较小的数字往后移动；当相等时，打完收工。当前后两个指标最后相遇时还没有找到，证明不存在解。<br>

本质上：是根据当前和的大小，逐步地以最小的步长去向目标靠拢，除非不存在解，否则一定可以找到。<br>

**代码：**<br>
```java
int small=0;          //初始时，分别指向第一个和最后一个下标。
int big=a.length-1;        
        
while(small != big){
    if(a[small]+a[big] == N){
        print(a[small]+","+a[big]);
        break;
    }
    if(a[small]+a[big] > N)
        big--;
    if(a[small]+a[big] < N)
        small++;
}
```
若是说，在无序的数组中寻找两个和为指定值的元素，那么只需要通过O(nlogn)进行排序，之后再按照上述操作就可以了。<br>

-------
##数组中出现次数超过一半的数字
**题目：**数组中有一个数字出现的次数超过了数组长度的一半，找出这个数字。<br>

**示例** int[] a = {1,2,4,2,3,2,5,2,2} 输出：2<br>

**方案1：**若是数组为排好序的，则中间位置的那个数，一定是为所求。<br>
所以可以先将数组排序，然后直接输出中间的那个数。平均的排序时间为O(nlogn)。<br>

**方案2：**不排序，依次统计每一元素的次数，使用哈希表。时间为遍历一次数组的时间加上遍历一次哈希表，找到其中最大的次数的时间。并且，哈希表还要占用一定的空间。<br>

**方案3：**我们应该注意到，要找的数字出现的次数比其他所有数字出现次数的和还要多。<br>
因此在遍历数组的时候保存两个值：一个是数组中的一个数字，一个是次数。<br>
当我们遍历到下一个数字的时候，如果下一个数字和我们之前保存的数字相同，则次数加1。如果下一个数字和我们之前保存的数字不同，则次数减1。如果次数为零，我们需要保存下一个数字，那么要找的数字肯定是最后一次保存的数字。<br>

**代码：**<br>
```java
int find(int[] a) {
    int num = a[0];  //记录数据，先赋予第一个元素
    int count = 1;   //统计次数
    int i = 0;       //用于遍历

    while (i < a.length - 1) {
    	if (a[i + 1] == num)    
        	count++;
    	else
        	count--;

    	if (count == 0){       //若为0，则后移
        	num = a[i + 2];
        	count = 1;
        }
    	i++;
    }
    return num;
}
```
-----------
##正整数二进制表示中的1的个数
**题目：** 输出一个正整数的二进制中1的个数。<br>

**示例：** 10（二进制为1010），则输出2<br>

**方案一:**<br>
基本思想：使用除法，不断除以2，记录余数为1时的次数。<br>
代码：
```java
while(i!=0){
    if(i%2!=0)
        num++;
    i = i/2;
 }
```
**方案二：**
基本思想：使用位运算（效率上高于方案一），通过不断的右移，记录最右位为1的次数。<br>
代码：<br>
```java
while(i!=0){
    if((i&1)!=0) //最后一位为1
        num++;
    i = i>>1;
}
```
注意：若输入为负数的时候，会导致死循环。<br>

**方案三：**
基本思想：一个数的二进制减去1之后，会发生这样的改变：从最右边的1开始到最后，所有位都会变反，而其他的位不变。<br>
将两者进行&运算后，从原来最右边的1开始就都变成了0。那么，有多少个1，就有多少次这样的运算。<br>

例：（以下都是二进制表示）<br>
1100-1=1011，1100&1011=1000<br>
1000-1=0111, 1000&0111=0000 <br>
一共进行了两次这样的运算（原始数中有两个1）<br>

代码：
```java
while(i!=0){
    num++;
    i =i&(i-1);
}
```
**扩展：**如何判断一个数是2的正次幂？<br>
通过上面，我们发现，2的正次幂的二进制表示中只有一个1。<br>
那么若n&(n-1)为0，则n就是2的正次幂。<br>

------
##单例模式
**定义：**确保一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。<br>
**优点：**<br>
1 在内存中只有一个对象，节省内存空间。<br>
2 避免频繁的创建销毁对象，可以提高性能。<br>
3 避免对共享资源的多重占用。<br>
4 可以全局访问。<br>

**要素：**<br>
1 私有的构造方法<br>
2 指向自己实例的私有静态引用<br>
3 以自己实例为返回值的静态的公有的方法<br>

**实现：**<br>
单例模式根据实例化对象时机的不同分为两种：一种是饿汉式单例，一种是懒汉式单例。<br>
饿汉式单例在单例类被加载时候，就实例化一个对象交给自己的引用；而懒汉式在调用取得实例方法的时候才会实例化对象。<br>

**代码：**<br>
```java
\\饿汉式单例
public class Singleton { 
    private static Singleton singleton = new Singleton(); 
    private Singleton(){} 
    public static Singleton getInstance(){ 
        return singleton; 
    } 
} 
```
```java
\\懒汉式单例
public class Singleton { 
    private static Singleton singleton; 
    private Singleton(){} 
     
    public static synchronized Singleton getInstance(){ 
        if(singleton==null){ 
            singleton = new Singleton(); 
        } 
        return singleton; 
    } 
} 
```
---------
##判断是否所有小字符串里的字母在大字符串里都有
**题目：**假设这有一个各种字母组成的字符串，假设这还有另外一个字符串，而且这个字符串里的字母数相对少一些。<br>
判断是否所有小字符串里的字母在大字符串里都有？<br>

**示例1 ：**
String 1: ABCDEFGHLMNOPQRS<br>
String 2: DCGSRQPOM<br>
输出true<br>

示例2：<br>
String 1: ABCDEFGHLMNOPQRS<br>
String 2: DCGSRQPOZ<br>
输出false<br>

**方案1：**轮询第二个字符串里的每个字母，看它是否同在第一个字符串里。从算法上讲，这需要O(n*m)次操作。<br>

**方案2：**先对这两个字符串的字母进行排序，然后同时对两个字串依次轮询。两个字串的排序需要(常规情况)O(m log m) + O(nlogn)次操作，之后的线性扫描需要O(m+n)次操作。<br>

**方案3：**只需要O(n+m)次操作。对第一个字串进行轮询，把其中的每个字母都放入一个Hashtable里。然后轮询第二个字串，在Hashtable里查询每个字母，看能否找到。如果找不到，说明没有匹配成功。<br>

**方案4：**假设我们有一个一定个数的字母组成字串 ——我给每个字母分配一个素数，从2开始，往后类推。这样A将会是2，B将会是3，C将会是5，等等。现在我遍历第一个字串，把每个字母代表的素数相乘。你最终会得到一个很大的整数。然后 轮询第二个字符串，用每个字母除它。如果除的结果有余数，这说明有不匹配的字母。如果整个过程中没有余数，那么它是第一个字串恰好的子集了。<br>

------------------
##找到数组中只出现一次的数字
**题目：**一个数组中的元素，只有一个数字出现了一次，其他的元素都出现两次。找出出现一次的这个数字。<br>

**示例:** {1,2,1,3,2,4,4}  输出：3<br>

**方案1：**<br>先将数组进行排序，这个数字一定是出现在第奇数位上（从1开始计数），并且这个数和后面的数不相同。
若没有找到这个数字，则其为排序后的最后一个数字。<br>
分析：进行排序的时间复杂度O(nlogn)，再遍历一遍为O(n)，则总体时间复杂度为O(nlogn)。<br>

**方案2：**根据异或的特性：相同两数异或为0，不同两数异或为1。将所有的数进行异或操作，则最终的结果即为所求。<br>
代码:<br>
```java
for(int i =1;i<a.length;i++)
    a[0] ^= a[i];
print(a[0]);
```
分析：仅遍历一遍，故时间复杂度为O(n)。<br>

**扩展：**若是有个数组，其中只有一个数N出现奇数次，其他的数都出现偶数次，怎样找到N?<br>

--------------
##折半查找(二分查找)
**思想：**将n个元素分成个数大致相同的两半，取a[n/2]与欲查找的x作比较，如果x=a[n/2]则找到x，算法终止。如果x<a[n/2]，则我们只要在数组a的左半部继续搜索x（这里假设数组元素呈升序排列）。如果x>a[n/2]，则我们只要在数组a的右半部继续搜索x。<br>

**分析：**它充分利用了元素间的次序关系，采用分治策略，可在最坏的情况下用O(logn)完成搜索任务。<br>

**代码：**
```java
public static boolean find(int n, int[] a, int start, int end) {
　　if (start > end)
　　　　return false;

　　int mid = (start + end) / 2;
　　if (n == a[mid])
　　　　return true;
　　else {
　　　　if (n > a[mid])
　　　　　　return find(n, a, mid + 1, end);
　　　　else
　　　　　　return find(n, a, start, mid - 1);
　　}
}
```

--------------
##从第一字符串中删除第二个字符串中所有的字符

**题目：**输入两个字符串，从第一字符串中删除第二个字符串中所有的字符。<br>

**示例：**输入”They are students.”和”aeiou”，输出 ”Thy r stdnts.”。<br>

**方案一：**在第一个字符串中拿到一个字符，在第二个字符串中查找一下，看它是不是在第二个字符串中。如果在的话，就从第一个字符串中删除。<br>

分析：由于字符串的内存分配方式是连续分配的。我们从字符串当中删除一个字符，需要把后面所有的字符往前移动一个字节的位置。但如果每次删除都需要移动字符串后面的字符的话，对于一个长度为n的字符串而言，删除一个字符的时间复杂度为O(n)。而对于本题而言，有可能要删除的字符的个数是n，因此该方法就删除而言的时间复杂度为O(n*m)。<br>

**方案二：**事实上，我们并不需要在每次删除一个字符的时候都去移动后面所有的字符。我们可以设想，当一个字符需要被删除的时候，我们把它所占的位置让它后面的字符来填补，也就相当于这个字符被删除了。在具体实现中，我们可以定义两个指针(pFast和pSlow)，初始的时候都指向第一字符的起始位置。当pFast指向的字符是需要删除的字符，则pFast直接跳过，指向下一个字符。如果pFast指向的字符是不需要删除的字符，那么把pFast指向的字符赋值给pSlow指向的字符，并且pFast和pStart同时向后移动指向下一个字符。这样，前面被pFast跳过的字符相当于被删除了。用这种方法，整个删除在O(n)时间内就可以完成。<br>

分析：接下来我们考虑如何在一个字符串中查找一个字符。当然，最简单的办法就是从头到尾扫描整个字符串。显然，这种方法需要一个循环，对于一个长度为n的字符串，查找判断的时间复杂度是O(m)。<br>

优化：由于字符的总数是有限的。对于八位的char型字符而言，总共只有256个字符。我们可以新建一个大小为256的数组，把所有元素都初始化为0。然后对于字符串中每一个字符，把它的ASCII码映射成索引，把数组中该索引对应的元素设为１。这个时候，要查找一个字符就变得很快了：根据这个字符的ASCII码，在数组中对应的下标找到该元素，如果为0，表示字符串中没有该字符，否则字符串中包含该字符。此时，查找一个字符的时间复杂度是O(1)。其实，这个数组就是一个hash表。<br>

**方案三：**将字符串放入字符数组中，逐个元素用hash的方式判断是否存在字符串2中，若不存在则输出。O(n)<br>
