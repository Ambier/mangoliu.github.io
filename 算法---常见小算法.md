#算法---常见小算法
##冒泡排序
冒泡排序算法:轻者上浮，重者下沉。（或者正好相反） <br>
**基本思想：**<br>
1.比较相邻的元素。<br>
2.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。<br>
3.针对所有的元素重复以上的步骤，除了最后一个。<br>
4.持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。<br>
本质上是：第一趟，选出最大（或最小）元素，第二趟，选出次大（或次小的）的元素…..<br>
<br>
**示例：**<br>
定义数组：{ 4, 2, 62, 9, 22, 1,14,10 }<br>
第1趟排序后：[2, 4, 9, 22, 1, 14, 10, 62]  //选取最大元素62，放在了最后<br>
第2趟排序后：[2, 4, 9, 1, 14, 10, 22, 62]  //选出了次大元素22 ，放在了倒数第二位….<br>
第3趟排序后：[2, 4, 1, 9, 10, 14, 22, 62]<br>
第4趟排序后：[2, 1, 4, 9, 10, 14, 22, 62]<br>
第5趟排序后：[1, 2, 4, 9, 10, 14, 22, 62]<br>
第6趟排序后：[1, 2, 4, 9, 10, 14, 22, 62]<br>
第7趟排序后：[1, 2, 4, 9, 10, 14, 22, 62]<br>
<br>
**代码：**<br>
```java
//沉底操作
int i,j,t;
int [] a={4,2,6,9,22,1,100};
for(i=0;i<n-1;i++){
   for(j=0;j<n-i-1;j++){   //注意这两个for循环是怎么写的。
      if(a[j]>a[j+1]){   //满足条件的话，交换两个元素。
        t=a[j];
        a[j]=a[j+1];
        a[j+1]=t;
      }
  }
}
```
**时间复杂度**：<br>
最好情况，O(n)；最坏(逆序) O(n*n)。是稳定的排序。
稳定排序：待排序的记录序列中可能存在两个或两个以上关键字相等的记录。
排序前的序列中Ri领先于Rj。若在排序后的序列中Ri仍然领先于Rj，则称所用的方法是稳定的。<br>

------
##先序遍历二叉树
**前序遍历：**先遍历父节点，然后左子节点，然后右子节点。<br>
下图的遍历顺序为：1245367<br>
![tree](/images/suanfa/20141203.png)<br>

**递归方式基本思想：**<br>
对一个树的访问，可以分成访问当前节点，访问左子树和访问右子树。而访问左右子树时又可以看做是上述步骤的重复，因此可以递归的调用。<br>

**代码：**<br>
```java
//递归方式
void preOrder(TNode* root){
    if (root != NULL){
        Visit(root);           //访问当前节点
        preOrder(root->left);   //递归访问左子节点
        preOrder(root->right);   //递归访问右子节点
    }
}
```
**非递归方式基本思想：**<br>
在访问途中将依次遇到的节点保存下来。由于节点出现次序与恢复次序是反序的，因此是一个先进后出结构，需要用栈。<br>
**代码：**<br>
```java
//非递归方式
void preOrder1(TNode* root){
    Stack S;
    while ((root != NULL) ||!S.empty()) {
        if (root != NULL) {
            Visit(root);
            S.push(root);       // 先访问，再入栈
            root = root->left;    // 依次访问左子树
        }
        else{
            root = S.pop();     // 回溯至父亲节点
            root = root->right;
        }
    }
}
```
------
##排序数组中和为给定值的两个数字
**题目：**有一个升序的数组a和一个数字N，在数组中查找两个数，使得它们的和正好是输入的那个数字。要求时间复杂度是O(n)。如果有多对数字的和等于输入的数字，输出任意一对即可。<br>

**示例：**数组1、2、4、7、11、15以及目标和15。由于4+11=15，因此输出4和11。<br>

**方案一：**穷举遍历法，一个个比对查找，但这种方法没有好好利用有序这个条件。时间复杂度为O(n*n)。<br> 
**方案二：**基本思路：找到两个数，将其和与N进行对比，并不断调整。<br>

**实现方法：**找到数组的第一个数字和最后一个数字。当两个数字的和大于输入的数字时，把较大的数字往前移动；当两个数字的和小于数字时，把较小的数字往后移动；当相等时，打完收工。当前后两个指标最后相遇时还没有找到，证明不存在解。<br>

本质上：是根据当前和的大小，逐步地以最小的步长去向目标靠拢，除非不存在解，否则一定可以找到。<br>

**代码：**<br>
```java
int small=0;          //初始时，分别指向第一个和最后一个下标。
int big=a.length-1;        
        
while(small != big){
    if(a[small]+a[big] == N){
        print(a[small]+","+a[big]);
        break;
    }
    if(a[small]+a[big] > N)
        big--;
    if(a[small]+a[big] < N)
        small++;
}
```
-------
##数组中出现次数超过一半的数字
**题目：**数组中有一个数字出现的次数超过了数组长度的一半，找出这个数字。<br>

**示例** int[] a = {1,2,4,2,3,2,5,2,2} 输出：2<br>

**方案1：**若是数组为排好序的，则中间位置的那个数，一定是为所求。<br>
所以可以先将数组排序，然后直接输出中间的那个数。平均的排序时间为O(nlogn)。<br>

**方案2：**不排序，依次统计每一元素的次数，使用哈希表。时间为遍历一次数组的时间加上遍历一次哈希表，找到其中最大的次数的时间。并且，哈希表还要占用一定的空间。<br>

**方案3：**我们应该注意到，要找的数字出现的次数比其他所有数字出现次数的和还要多。<br>
因此在遍历数组的时候保存两个值：一个是数组中的一个数字，一个是次数。<br>
当我们遍历到下一个数字的时候，如果下一个数字和我们之前保存的数字相同，则次数加1。如果下一个数字和我们之前保存的数字不同，则次数减1。如果次数为零，我们需要保存下一个数字，那么要找的数字肯定是最后一次保存的数字。<br>

**代码：**<br>
```java
int find(int[] a) {
    int num = a[0];  //记录数据，先赋予第一个元素
    int count = 1;   //统计次数
    int i = 0;       //用于遍历

    while (i < a.length - 1) {
    	if (a[i + 1] == num)    
        	count++;
    	else
        	count--;

    	if (count == 0){       //若为0，则后移
        	num = a[i + 2];
        	count = 1;
        }
    	i++;
    }
    return num;
}
```
-----------
##正整数二进制表示中的1的个数
**题目：** 输出一个正整数的二进制中1的个数。<br>

**示例：** 10（二进制为1010），则输出2<br>

**方案一:**<br>
基本思想：使用除法，不断除以2，记录余数为1时的次数。<br>
代码：
```java
while(i!=0){
    if(i%2!=0)
        num++;
    i = i/2;
 }
```
**方案二：**
基本思想：使用位运算（效率上高于方案一），通过不断的右移，记录最右位为1的次数。<br>
代码：<br>
```java
while(i!=0){
    if((i&1)!=0) //最后一位为1
        num++;
    i = i>>1;
}
```
注意：若输入为负数的时候，会导致死循环。<br>

**方案三：**
基本思想：一个数的二进制减去1之后，会发生这样的改变：从最右边的1开始到最后，所有位都会变反，而其他的位不变。<br>
将两者进行&运算后，从原来最右边的1开始就都变成了0。那么，有多少个1，就有多少次这样的运算。<br>

例：（以下都是二进制表示）<br>
1100-1=1011，1100&1011=1000<br>
1000-1=0111, 1000&0111=0000 <br>
一共进行了两次这样的运算（原始数中有两个1）<br>

代码：
```java
while(i!=0){
    num++;
    i =i&(i-1);
}
```
**扩展：**如何判断一个数是2的正次幂？<br>
通过上面，我们发现，2的正次幂的二进制表示中只有一个1。<br>
那么若n&(n-1)为0，则n就是2的正次幂。<br>
------
##单例模式
**定义：**确保一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。
**优点：**
1 在内存中只有一个对象，节省内存空间。
2 避免频繁的创建销毁对象，可以提高性能。
3 避免对共享资源的多重占用。
4 可以全局访问。

**要素：**
1 私有的构造方法
2 指向自己实例的私有静态引用
3 以自己实例为返回值的静态的公有的方法

**实现：**
单例模式根据实例化对象时机的不同分为两种：一种是饿汉式单例，一种是懒汉式单例。
饿汉式单例在单例类被加载时候，就实例化一个对象交给自己的引用；而懒汉式在调用取得实例方法的时候才会实例化对象。

**代码：**
```java
\\饿汉式单例
public class Singleton { 
    private static Singleton singleton = new Singleton(); 
    private Singleton(){} 
    public static Singleton getInstance(){ 
        return singleton; 
    } 
} 
```
```java
\\懒汉式单例
public class Singleton { 
    private static Singleton singleton; 
    private Singleton(){} 
     
    public static synchronized Singleton getInstance(){ 
        if(singleton==null){ 
            singleton = new Singleton(); 
        } 
        return singleton; 
    } 
} 
```
---------