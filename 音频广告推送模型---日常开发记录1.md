#音频广告推送模型---日常开发记录1
--------------------------------
## 初步方案确定：
1 登陆用户的属性标签，以及其各个音乐行为维度,用作训练集。<br>
2 确定8个维度：时间(event_hour),省份(event_province),城市(event_city),四端(terminal_type),歌曲(song_id),歌手(singer_name),设备(device_model),专辑(album_id)<br>
3 这个相当于根据一个用户的多维度，来推测出多属性。(注意不是单一属性)<br>
  我们先从单一属性入手，不断深入。先从“购物”属性入手，因为数量大，变现能力强。<br>
4 在登陆用户中，需要找到一部分涉及“购物”的人，一部分不涉及的人用作训练集。还要留一部分作为测试集。<br>

## 近期计划：
1 获取几天bhv_play表中的登陆用户的播放数据。注意BDUSS解码。<br>
2 提取其中的useID，通过大数据部的[厄里斯魔镜接口](https://github.com/MangoLiu/mangoliu.github.io/blob/master/%E9%9F%B3%E9%A2%91%E5%B9%BF%E5%91%8A%E6%8E%A8%E9%80%81%E6%A8%A1%E5%9E%8B---%E5%8E%84%E9%87%8C%E6%96%AF%E9%AD%94%E9%95%9C%E6%8E%A5%E5%8F%A3.md)接口，获得用户侧写的属性。<br>
3 文本的预处理：离散化、缺省值、归一化等处理，还要处理成libsvm指定格式。
  之后还需要将文本分割成训练集和测试集。训练集中要有正反类别（即包含“购物”属性与否）。<br>
4 使用[libsvm(baidu百科)](http://baike.baidu.com/view/598089.htm?fr=aladdin)进行训练，学习svm参数调优以及核函数优化。<br>
5 使用训练好的模型，根据非登录用户的行为进行单一维度判断。<br>

## 注意：
1 筛选特定属性的函数要具有普遍适用性，并且适应属性集不断扩张的需求。<br>
2 文本预处理函数也是如上，并且要有很好的容错性。<br>

## 这样做的缺点：
1 根据用户行为出发广告，只是根据他的上一次播放请求。而与近期的历史操作无关。<br>
2 N个标签，需要N次二分判断，需要N个模型来存储。<br>
3 这里使用svm的效果，个人主观上认为不如KNN效果好。<br>
但好处就是这种学习型模型，训练好了之后速度快。并且也是考虑到开发时间短。


## 后续待做：
1 非登录用户的扩张功能。<br>
2 属性值后面携带的可能性数值没有利用上。

###### (以上写于2014-10-10)

##一些想法
1 获取数据集时，注意数据偏颇。
> 获取登陆用户的数据，但移动端的用户登陆比例极低。导致获取的100w数据全都是web端的。

2 从上面可以看出账号系统的重要性。益处实在是多，它可以跨产品集成信息，公司业务越大，带来的优势越明显。

## 更新：
1 <strong>获取用户播放信息方式变更</strong><br>
之前的设计有个缺陷，就是我们数据库中的用户播放行为数据并不是实时插入的，这些中间层是以天为单位进行写入的。而大表是以小时为单位写入的。而我要求的实时性是要以秒为单位的。所以我们的数据表并不能支撑之前的设计。所有有所更改：由web-rd给我传递，然后我再添加一些维度来计算。<br>
web-rd给我传递：userid，baiduid，cuid，地理信息，songid，singerid。<br>
我再添加上：time以及四端信息。<br>

2 <strong>在线厄里斯https方式获取登陆用户信息</strong><br>
之前在训练模型时，使用的是工具批量获取信息。而在真正的使用场景中，则是需要通过在线请求的方式来获取的。<br>
内部课程：[pbrpc的使用和实现介绍](http://learn.baidu.com/courseInfo.html?courseId=3046)。<br>
rpc([远程过程调用协议_百度百科](http://baike.baidu.com/view/7287257.htm?fromtitle=RPC&fr=aladdin))是公司内部的一个广义的业务间的通信协议。<br>
根据[pbrpc4j_wiki](http://wiki.babel.baidu.com/twiki/bin/view/Com/Main/Hulu_pbrpc4j)，工作如下：<br>
2.1 配置maven：<br>
maven简介：<br>
Maven是一个采用纯Java编写的开源项目管理工具。Maven采用了一种被称之为project object model(POM)概念来管理项目，所有的项目配置信息都被定义在一个叫做POM.xml的文件中，通过该文件，Maven可以管理项目的整个声明周期，包括编译，构建，测试，发布，报告等等。<br>

3 libsvm中的svm_node是一个包含index和value的对象。<br>

4 不断的打印出当前的信息，是调试程序的一个不错方式。<br>

5 svm_parameter.java 中可以看到各种参数的名称，以及对应值。<br>

6 svm_train.java中的parse_command_line方法用户解析参数，其中也提供了默认参数的配置，若是需要改变默认函数，则在这里进行修改。<br>

7 libsvm在处理预测是，使用的是导入文件进行读取，再把结果保存在文件中。<br>
  这种方式并不适合我们一条条判断的方式，因此需要对libsvm的源代码进行下改写。<br>
  原则：不在原来的方法上直接进行修改。而是仿照方法再写一个新的方法。这样保证可回退性和可选择性。<br>

8 对于cuid判断预测时，需要逐个加载model：<br>
```java
     StringBuffer sb  = new StringBuffer();
     for(int i = 0 ;i<TAGS.TAGS.length;i++){
    	 String model = TAGS.TAGS[i]+".model";
 		
 		String[] argvPredict = { 
 				cuid_result, // 预测文件
 				model // 模型文件
 		};
 		try {
 			sb.append(svm_predict.predictStr(argvPredict));
 		} catch (IOException e) {
 			return ENUM.DEFALUT_RESULT;
 		}
     }//for
```
这样的性能时间约为750ms，太耗时了。<br>
svm.java中是这样加载model的：<br>
```java
public static svm_model svm_load_model(String model_file_name) throws IOException
	{
		return svm_load_model(new BufferedReader(new FileReader(model_file_name)));
	}
```
使用static块处理，这样在程序运行之前，就加载到内存中，并且只加载一次：<br>
```java
public static svm_model[] SVM_MODELS = new svm_model[TAGS.TAGS.length];
	static{
		for(int i = 0;i<SVM_MODELS.length;i++)
			try {
				SVM_MODELS[i] =svm.svm_load_model(new BufferedReader(new FileReader(TAGS.TAGS[i]+".model")));
			} catch (FileNotFoundException e) {
				e.printStackTrace();
			} catch (IOException e) {
				e.printStackTrace();
			}	
	}
```



###参考文献：
1 [eclipse Maven配置_CSDN](http://blog.csdn.net/anialy/article/details/8226887),用于配置Maven。<br>
2 [pbrpc4j的wiki](http://wiki.babel.baidu.com/twiki/bin/view/Com/Main/Hulu_pbrpc4j),讲解pbrpc java版本。<br>
3 maven的安装问题，参见本地文件《maven首次配置问题的解决.docx》<br>

--------------------------------
######（转载本站文章请注明作者和出处 <a href="https://github.com/MangoLiu">MangoLiu</a> ，请勿用于任何商业用途）


